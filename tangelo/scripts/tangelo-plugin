#!python

import argparse
import os
import urlparse
import subprocess
import sys

descriptions = {"install": "Download/prepare a Tangelo plugin for use",
                "enable": "Enable a Tangelo plugin",
                "disable": "Disable a Tangelo plugin",

def usage():
    msg = ["usage: tangelo-plugin <subcommand> [...]",
           "",
           "tangelo-plugin install -- %s" % (descriptions["install"]),
           "tangelo-plugin enable -- %s" % (descriptions["enable"]),
           "tangelo-plugin disable -- %s" % (descriptions["disable"]),
           "",
           "For more help on these subcommands, issue the subcommand with a '-h' flag."]

    print >>sys.stderr, "\n".join(msg)
    return 1

def install_args(args):
    sys.argv[0] += " install"

    p = argparse.ArgumentParser(description=descriptions["install"])
    p.add_argument("-u", "--url", type=str, default=None, metavar="URL", help="URL of a Git repository hosting the pluigin")
    p.add_argument("-p", "--path", type=str, required=True, metavar="PATH", help="Location of plugin on disk, or location to install plugin via Git")
    p.add_argument("--no-prepare", action="store_true", help="do not run the plugin preparation (installing dependencies, etc.)")

    return p.parse_args(args)

def install(path, url=None, prepare=None):
    print url
    print path
    print prepare

def enable_args(args, on):
    op = "enable" if on else "disable"
    sys.argv[0] += " %s" % (op)

    p = argparse.ArgumentParser(description=descriptions[op])
    p.add_argument("-p", "--plugin", type=str, required=True, metavar="PLUGIN", help="The name of the plugin to %s" % (op))
    p.add_argument("-c", "--config", type=str, default="./plugin.conf", metavar="FILE", help="The plugin config file to update (default: plugin.conf)")

    return p.parse_args(args)

def enable(plugin, config, on):
    print plugin
    print config
    print on

def main():
    retval = 0

    # Examine the first argument.
    if len(sys.argv) < 2:
        return usage()

    subcommand = sys.argv[1]
    args = sys.argv[2:]

    if subcommand == "install":
        args = install_args(args)
        return install(args.path, url=args.url, prepare=not args.no_prepare)
    elif subcommand == "enable":
        args = enable_args(args, True)
        return enable(args.plugin, args.config, True)
    elif subcommand == "disable":
        args = enable_args(args, False)
        return enable(args.plugin, args.config, False)
    else:
        return usage()

    # Get the pip executable from the same installation as the current script's
    # python.
    pip = os.path.join(sys.prefix, "bin/pip")

    # Treat the arguments as a list of plugin URIs.
    plugins = sys.argv[1:]
    for plugin in plugins:
        # Parse the URI.
        spec = urlparse.urlparse(plugin)

        if spec.scheme in ["", "file"]:
            # If the URI is a file path, simply attempt to install its
            # requirements, if any.
            reqfile = os.path.join(spec.path, "requirements.txt")
            if os.path.exists(reqfile):
                code = subprocess.call([pip, "install", "-r", reqfile])
                if code != 0:
                    retval = 1
            elif not os.path.exists(spec.path):
                print >>sys.stderr, "error: plugin directory %s does not exist" % (spec.path)
                retval = 1
            else:
                print >>sys.stderr, "plugin directory %s has no requirements.txt file, continuining" % (spec.path)
        elif spec.scheme in ["http", "https", "git"]:
            # TODO: use git to clone the repository, and the follow up by taking
            # the "filesystem" actions as above.
            print >>sys.stderr, "%s scheme processing unimplemented" % (spec.scheme)
            retval = 2
        else:
            print >>sys.stderr, "error: unsupported URI scheme '%s'" % (spec.scheme)
            retval = 1

    return retval

if __name__ == "__main__":
    sys.exit(main())
